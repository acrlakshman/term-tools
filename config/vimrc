" Wenzel's .vimrc

" Useful shortcuts:
" Ctrl-O/I: move forward/backwards through previously visited buffer positions

" use ]p/]P to paste while respecting the current indent level.
" gv re-selects a previous visual selection
" git log origin/master ^master --stat
" 
" <leader> s/f/F -- EasyMotion 1 character searches 
" <leader> j/k   -- EasyMotion row searches
" <leader> m     -- run make
" <leader> p/P   -- indented paste
" <leader> dw    -- fix trailing ^M characters
" <leader> l     -- format Python/C++ code

set nocompatible

" Plugins {{{

filetype off " Needed (this interferes with Vundle)

set rtp+=~/.vim/bundle/Vundle.vim/

call vundle#begin() " required

" Let Vundle manage Vundle
Plugin 'gmarik/Vundle.vim'
" Assorted scripts, modified tomorrow night colorscheme
Plugin 'wjakob/wjakob.vim'
" Airline status bar
Plugin 'bling/vim-airline'
" C++/Python autocompletion
Plugin 'Valloric/YouCompleteMe'
" Git integration
Plugin 'tpope/vim-fugitive'
" GUI extension for the fugitive plugin
Plugin 'gregsexton/gitv'
" IPython integration
Plugin 'ivanov/vim-ipython'
" Easymotion plugin
Plugin 'Lokaltog/vim-easymotion'
" Support for directly opening file:linenumber
Plugin 'bogado/file-line'
" Convenient recursive filename search
Plugin 'ctrlp.vim'
" Accelerates loading of big files
Plugin 'mhinz/vim-hugefile'
" Format Python files
Plugin 'tell-k/vim-autopep8'
" Cmake integration
Plugin 'vhdirk/vim-cmake'
" Ag searcher
Plugin 'rking/ag.vim'
" Google calendar viewer
Plugin 'itchyny/calendar.vim'
" Snippet manager
Plugin 'SirVer/ultisnips'
" Nice indentation marks
Plugin 'Yggdroot/indentLine'
" Show marks visually
Plugin 'ShowMarks'
" Hard mode :)
Plugin 'takac/vim-hardtime'
" Automatic generation of closing braces etc
Plugin 'Raimondi/delimitMate'
" Easily comment / uncomment text
Plugin 'scrooloose/nerdcommenter'
" Maximize a buffer and restore later on (C-W o)
Plugin 'regedarek/ZoomWin'
" Git gutter
Plugin 'airblade/vim-gitgutter'
" Secure way of sourcing local vimrc files
Plugin 'MarcWeber/vim-addon-local-vimrc'
" Delete all but the current buffer
Plugin 'vim-scripts/BufOnly.vim'

call vundle#end() " required

filetype plugin indent on

" }}}

" Core VIM settings {{{
set encoding=utf-8             " use UTF-8 (default latin1)
set autoread                   " auto-reload modified files (with no local changes)
set undolevels=65536           " lots of undo (default 1000)
set history=1024               " lots of history (default 20)
set mouse=a                    " enable mouse (set mouse= to disable mouse)
set hidden                     " allow un-saved buffers in background
set lazyredraw                 " no redraws in macros
set confirm                    " dialog when :q, :w, :x, :wq fails
set title                      " change terminal title
set nostartofline              " don't move cursor when switching buffers/files
set ttyfast                    " smoother changes
set backspace=2                " Backspace can move back beyond the start of the insertion
set backspace=indent,eol,start " Make backspace behave more like in other editors
set splitbelow                 " Open splits below (more natural), :sp makes a split
set splitright                 " Similar to the above (for vsplit)
let mapleader=","              " Map the leader key to comma

" Control what extra information is shown
set showmode                   " show which mode we are in
set showcmd                    " show state of keyboard input
set showmatch                  " show brace match
set matchtime=2                " when writing braces, only briefly flash the opening one (200ms)
set report=0                   " always report how many occurrences were changed by search/replace etc
set ruler                      " show position in bottom right
set winminheight=0             " allow to collapse down windows to their status line only

" Tabs, wrapping, folding, and indentation
set autoindent                 " automatic indentation
set copyindent                 " copy the previous indentation on autoindenting
set smartindent                " enable C-style indenting by default (useful for C/C++)
set tabstop=4                  " Number of spaces that a <Tab> in the file counts for (default 8)
set shiftwidth=4               " Number of spaces to use for each step of (auto)indent.
set softtabstop=-1             " Disable softtabstop (reverts to shiftwidth)
set smarttab                   " insert tabs on the start of a line according to
                               " shiftwidth, not tabstop
set textwidth=0                " no hard wrapping by default
set foldmethod=syntax          " fold using syntax by default
set foldminlines=4             " require a medium size to fold
set foldnestmax=3              " max 3 fold levels for syntax/indent folding

" Appearance
set number                     " enable line numbers
set scrolloff=3                " keep 3 lines below and above cursor
set linebreak                  " show wrap at word boundaries
set showbreak=\ ↪\             " prefix wrap with ↪

" Autocompletion
set wildmenu                   " completion with menu
set wildmode=full              " show list with navigation
set wildignore=*~,*.o,*.d,*.obj,*.class,*.pyc,*.bak,*.swp,.svn,.git,.hg
set suffixes=~,.o,.d,.obj,.class,.pyc,.bak,.swp
set completeopt=menu,preview   " Completion with a menu

" Searching
set incsearch                  " incremental search
set hlsearch                   " enable search highlighting

" Store swapfiles in a central location
set backup
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set backupskip=/tmp/*,/private/tmp/*
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set writebackup

set spelllang=en
set spellfile=$HOME/Dropbox/spell-en.utf-8.add

" Window navigation {{{
" Move around using Alt + navigation keys
nmap <silent> <M-k> :wincmd k<CR>
nmap <silent> <M-j> :wincmd j<CR>
nmap <silent> <M-h> :wincmd h<CR>
nmap <silent> <M-l> :wincmd l<CR>
nmap <silent> <M-o> :ZoomWin<CR>

" As above (Mac keyboard)
nmap <silent> ˙ :wincmd h<CR>
nmap <silent> ∆ :wincmd j<CR>
nmap <silent> ˚ :wincmd k<CR>
nmap <silent> ¬ :wincmd l<CR>
nmap <silent> ø :ZoomWin<CR>

" Window resize / close commands
nnoremap <silent> <C-L> :vertical resize -5<cr>
nnoremap <silent> <C-H> :vertical resize +5<cr>
nnoremap <silent> <C-K> :resize +5<cr>
nnoremap <silent> <C-J> :resize -5<cr>
nnoremap <silent> <C-X> :wincmd c<CR>     " close
nnoremap <silent> <C-F> <C-W>_            " fullscreen

" Move to next / previous buffer
nnoremap <silent> < :bp<CR>
nnoremap <silent> > :bn<CR>

" ctrl+a : select all
nmap <C-A> 1GVG

vnoremap Q gqp
nnoremap Q gqap

" Move by displayed lines, not physical lines
nnoremap j gj
nnoremap k gk

" Map cn/cp to navigate through search results (formerly :cn/:cp)
nnoremap cn :cn<CR>zv
nnoremap cp :cp<CR>zv

" Use Q for formatting the current paragraph (or selection)
" Allow 'gf' to jump to file:line links
"nnoremap gf gF

" Bind F2 as a quick paste mode toggle key
set pastetoggle=<F2>

" Hide shown search results
nmap <silent> ,/ :nohlsearch<CR>

" Automaticall unfold when jumping to a line in a file
nnoremap <expr> G (v:count ? 'Gzv' : 'G')

" }}}

" Tell vim to remember certain things when we exit
"  '50  :  marks will be remembered for up to 50 previously edited files
"  "100 :  will save up to 100 lines for each register
"  :50  :  up to 20 lines of command-line history will be remembered
"  %    :  saves and restores the buffer list
"  n... :  where to save the viminfo files
set viminfo='50,\"100,:50,%,n~/.viminfo

" }}}

" Global fixes {{{

" Be quiet
set noerrorbells visualbell t_vb=  " No bell
au GUIEnter * set visualbell t_vb= " No bell in GUI mode

" Faster timeouts
set timeout timeoutlen=1000 ttimeoutlen=100

" Use OS clipboard
if has('unix') && system("uname") == "Linux\n"
    set clipboard=unnamedplus  " Share X windows clipboard.
else
    set clipboard=unnamed      " Share system clipboard.
endif

" Re-adjust windows on window resize
autocmd VimResized * wincmd =

" Insert mode -- don't create/close folds when typing
autocmd InsertEnter * if !exists('w:last_fdm') | let w:last_fdm=&foldmethod | setlocal foldmethod=manual | endif
autocmd InsertLeave,WinLeave * if exists('w:last_fdm') | let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif

" Remove the toolbar if we're running under a GUI
if has("gui_running")
  set guioptions=-t
endif

if has('mac')
	fixdel
endif

" Jump to last known line when opening a file (change ' to ` to do column too)
autocmd BufReadPost *
  \ if line("'\"") > 0 && line("'\"") <= line("$") |
  \   exe "normal g'\"" |
  \   if foldlevel('.') > 0 |
  \     exe "normal zO" |
  \   endif |
  \ endif

" Delete trailing white space
fun! DeleteTrailingWS()
	exe "normal mq"
	%s/\s\+$//ge
	exe "normal `q"
	":ShowMarksClearMark
endfun

" }}}

" Color scheme {{{

set t_Co=256
set background=dark
syntax on
colorscheme tomorrow-night
hi Folded ctermfg=248 ctermbg=237 guibg=#3a3a3a guifg=#a8a8a8

" }}}

" Plugin config {{{
" Powerline -- fancy status line
if !exists('g:airline_symbols')
	let g:airline_symbols = {}
endif
let g:airline_left_sep = '⮀'
let g:airline_left_alt_sep = '⮁'
let g:airline_right_sep = '⮂'
let g:airline_right_alt_sep = '⮃'
let g:airline_symbols.branch = '⭠'
let g:airline_symbols.readonly = '⭤'
let g:airline_symbols.linenr = '⭡'
let g:airline_powerline_fonts=1
let g:airline#extensions#whitespace#enabled = 0
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#left_sep = ' '
let g:airline#extensions#tabline#left_alt_sep = '|'
let g:airline_theme='base16'

set laststatus=2  " 2 means always show status

" YouCompleteMe settings
let g:ycm_global_ycm_extra_conf = "~/.vim/.ycm_extra_conf.py"
let g:ycm_filetype_whitelist = {'cpp' : '', 'python' : '' }
let g:ycm_key_list_previous_completion = ['<S-TAB>']
let g:ycm_key_list_select_completion = ['<TAB>']
let g:ycm_confirm_extra_conf = 0
let g:ycm_autoclose_preview_window_after_insertion = 1
let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_enable_diagnostic_signs = 0
"
" CtrlP setting
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
"  ignore files
let g:ctrlp_custom_ignore = {
	\ 'dir':  '\.git$\|\.hg$\|\.svn\|\CMakeFiles$',
	\ 'file': '\.exe$\|\.so$\|\.dll$\|\.o$\|\.d$\|\.swp$',
	\ }

" Search the whole repository (searches for .git/.hg/.svn..)
let g:ctrlp_working_path_mode = 'r'

" refresh file tree on write or focus change
augroup CtrlPExtension
  autocmd!
  autocmd FocusGained * ClearCtrlPCache
  autocmd BufWritePost * ClearCtrlPCache
augroup END

" Folding for TeX files
"let g:tex_fold_enabled = 1

" Bi-directional find motion
" Jump to anywhere you want with minimal keystrokes, with just one key binding.
" `s{char}{label}`
map <Leader> <Plug>(easymotion-prefix)
nmap s <Plug>(easymotion-s)
omap s <Plug>(easymotion-s)

let g:autopep8_disable_show_diff = 1

let g:calendar_google_calendar = 1
let g:calendar_date_endian = "little"
let g:calendar_first_day = "monday"
let g:calendar_clock_12hour = 1
let g:calendar_frame = "unicode"
let g:calendar_date_separator = "."
let g:calendar_view = "days"

" UltiSnips shortcuts
let g:UltiSnipsExpandTrigger       = "<tab>"
let g:UltiSnipsJumpForwardTrigger  = "<tab>"
let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"

function! g:UltiSnips_Complete()
    call UltiSnips#ExpandSnippet()
    if g:ulti_expand_res == 0
        if pumvisible()
            return "\<C-n>"
        else
            call UltiSnips#JumpForwards()
            if g:ulti_jump_forwards_res == 0
               return "\<TAB>"
            endif
        endif
    endif
    return ""
endfunction

" Get rid of bad habits
let g:hardtime_default_on = 1
let g:hardtime_allow_different_key = 1
let g:hardtime_maxcount = 1
set mouse=
inoremap  <Up>     <NOP>
inoremap  <Down>   <NOP>
inoremap  <Left>   <NOP>
inoremap  <Right>  <NOP>
noremap   <Up>     <NOP>
noremap   <Down>   <NOP>
noremap   <Left>   <NOP>
noremap   <Right>  <NOP>

au InsertEnter * exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=g:UltiSnips_Complete()<cr>"

" Indentline
let g:indentLine_char = '¦'
let g:indentLine_color_term = 236
let g:indentLine_fileType = ['python']

" Show marks
let showmarks_include = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

" Convenient key binding for delimitMate
inoremap {<CR> {<CR>}<C-o>O

let g:indentLine_faster = 1

" Visualize TeX characters using the conceal feature
let g:tex_conceal="adgm"
set ambw="double"

let g:gitgutter_map_keys = 0
nmap [h <Plug>GitGutterPrevHunk
nmap ]h <Plug>GitGutterNextHunk
nmap <Leader>hs <Plug>GitGutterStageHunk
nmap <Leader>hr <Plug>GitGutterRevertHunk

" }}}

" Filetype-specific settings {{{

" SCons* files are Python scripts
au BufRead,BufNewFile SCons* set filetype=python

" Latex and Python: do not use tabs
au FileType python setlocal expandtab
au FileType cmake setlocal expandtab tabstop=2 shiftwidth=2
au FileType tex,plaintex setlocal expandtab conceallevel=2 concealcursor=nc
au BufEnter *.tex hi Conceal ctermfg=4

" Vimrc -- fold with markers
au FileType vim setlocal foldmethod=marker

" Mathematica binding files
au BufNewFile,BufRead *.tm set filetype=cpp

" C/C++ -- smart indentation
au FileType cpp setlocal cindent

" Spell-check text files
au FileType text,tex,html setlocal spell

" Highlight repeated words
au FileType text,tex,html syn match TmlDoubleWords /\c\<\(\S\+\)\_s\+\1\ze\_s/ containedin=ALL
au FileType text,tex,html hi link TmlDoubleWords WarningMsg

" Autocompletion
au FileType python,cpp nnoremap J :YcmCompleter GoTo<CR>zv

" }}}

" Mitsuba specific {{{

" Highlight trailing whitespace in the most annoying way possible.
fun! HighlightTrailingSpaces()
	hi ExtraWhitespace ctermbg=red guibg=red
	au ColorScheme * hi ExtraWhitespace ctermbg=red guibg=red
	match ExtraWhitespace /\s\+$/
	au BufWinEnter * match ExtraWhitespace /\s\+$/
	au InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
	au InsertLeave * match ExtraWhitespace /\s\+$/
endfun

let c_no_curly_error=1 " Be more lenient with C++11 syntax
au Syntax cpp syn keyword cType Float

au BufNewFile,BufRead *mitsuba* call HighlightTrailingSpaces()

" }}}

" PBRT editing environment {{{

au BufNewFile,BufRead */pbrt-3ed/src/* syntax match PBRTRef /^\/\*\s\p*:\d*\s\*\/ / conceal | set conceallevel=2 concealcursor=nc

function JumpToFile()
	if matchstr(expand('%:p'), '.*/pbrt-3ed/src/.*') != ''
		" This is PBRT code: move to the column with file/line number information and jump
		normal 3|gF
	else
		" Perform a normal jump
		normal gF
	endif
endfunction

python << EOF
def pbrt_search(search):
	import os, glob, vim
	search += ">="
	for name in list(glob.iglob('ch*.tex')) + list(glob.iglob('app*.tex')):
		with open(name, 'r') as f:
			lines = f.readlines()
			for row, text in enumerate(lines):
				col = text.find(search)
				if col != -1:
					vim.command("silent edit %s:%i:%i" % (name, row+1, col+1))
EOF

function! PBRTJump()
	let l:save_clipboard = &clipboard
	set clipboard= " Avoid clobbering the selection and clipboard registers.
	let l:save_reg = getreg('"')
	let l:save_regmode = getregtype('"')
	normal! ya<
	let l:text = @@
	call setreg('"', l:save_reg, l:save_regmode)
	let &clipboard = l:save_clipboard
	python pbrt_search(vim.eval('l:text'))
endfunction

nnoremap gf :call JumpToFile()<CR>
au BufNewFile,BufRead ~/pbrt-3ed/book/*.tex setlocal cindent | let cur_syntax = b:current_syntax | unlet! b:current_syntax | syntax include @CPP syntax/cpp.vim | syntax region cppSnip matchgroup=Snip start=/^@.*=$/ end=/^@\./ contains=@CPP | nnoremap J :call PBRTJump()<CR>

" }}}
" Other commands and abbreviations {{{

" Multiprocessor builds
function! SetMakeprg()
	if !empty($NUMBER_OF_PROCESSORS)
		let n = $NUMBER_OF_PROCESSORS + 0
	elseif has('mac')
		let n = system("sysctl -n hw.ncpu")
	elseif filereadable('/proc/cpuinfo')
		let n = system('grep -c ^processor /proc/cpuinfo') + 0
	else
		let n = 1
	endif
	let &makeprg = 'make' . (n > 1 ? (' -j'.(n + 1)) : '')
endfunction
call SetMakeprg()


function! CommandCabbr(abbreviation, expansion)
  execute 'cabbr ' . a:abbreviation . ' <c-r>=getcmdpos() == 1 && getcmdtype() == ":" ? "' . a:expansion . '" : "' . a:abbreviation . '"<CR>'
endfunction

command! -nargs=+ CommandCabbr call CommandCabbr(<f-args>)

command IPy execute 'IPython' | set foldmethod=marker | set foldmarker=#-,##

" Run make and don't prompt for ENTER
nmap <silent> <Leader>m :wa<CR>:silent! make! \| redraw! \| cw \| <CR><CR>zv
vmap <silent> <Leader>m :wa<CR>:silent! make! \| redraw! \| cw \| <CR><CR>zv

" Like the above, but open in a quickfix window
"command Makec make! | copen

" w!! command which writes with root permissions
cmap w!! w !sudo tee % >/dev/null

"CommandCabbr build makec
CommandCabbr ag Ag
CommandCabbr bc Bclose
CommandCabbr git Git
CommandCabbr gitv Gitv

" Automatically insert C++ header gates for new h/hpp files
function! s:insert_gates()
  let gatename = '__' . substitute(toupper(expand("%:t")), "\\.", "_", "g")
  execute "normal! i#if !defined(" . gatename . ")\n#define " . gatename
  execute "normal! Go#endif /* " . gatename . " */"
  execute "normal! ggjo"
endfunction

au BufNewFile *.{h,hpp} call <SID>insert_gates()

function! BackwardSkipConceal()
    let l = line(".")
    let c = col(".") - 1
    while synconcealed(l, c)[0] && c > 1
        if c <= 2
            break
        endif
        let c -= 1
    endwhile
    call cursor(l, c)
endfunction

function! ForwardSkipConceal()
    let l = line(".")
    let c = col(".")
    while synconcealed(l, c)[0]
        if c == col("$")
            break
        endif
        let c += 1
    endwhile
    call cursor(l, c+1)
endfunction

"smart indent when entering insert mode with i on empty lines
function! IndentWithI()
    if len(getline('.')) == 0
        return "\"_ddO"
    else
        return "i"
    endif
endfunction

nnoremap <silent> h :call BackwardSkipConceal()<cr>
nnoremap <silent> l :call ForwardSkipConceal()<cr>
nnoremap <expr> i IndentWithI()

" Execute a python script
au FileType python nnoremap <buffer> <leader>r <esc>:w !python3<cr>

" Paste into new line
nmap <leader>P O<space><bs><esc>]pk"_dd
nmap <leader>p o<space><bs><esc>]pk"_dd

" <leader>l to format Python
au FileType python nnoremap <buffer> <leader>l <esc>:call Autopep8()<cr><esc>:redraw!<CR>
au FileType cpp    map <buffer> <leader>l :pyf $TERM_TOOLS/config/clang-format.py<CR>

" Remove trailing newlines
noremap <silent> <leader>dw <esc>:call DeleteTrailingWS()<cr>
" Remove incorrect line endings from Windows machines
noremap <leader>dd :%s/\r\n/\r/g<CR>

nnoremap <buffer> ][ :<c-u>call <SID>JumpMethod('{', 'W',  'n')<cr>
nnoremap <buffer> [[ :<c-u>call <SID>JumpMethod('{', 'Wb', 'n')<cr>
nnoremap <buffer> ]] :<c-u>call <SID>JumpMethod('}', 'W',  'n')<cr>
nnoremap <buffer> [] :<c-u>call <SID>JumpMethod('}', 'Wb', 'n')<cr>

xnoremap <buffer> ][ :<c-u>call <SID>JumpMethod('{', 'W',  'v')<cr>
xnoremap <buffer> [[ :<c-u>call <SID>JumpMethod('{', 'Wb', 'v')<cr>
xnoremap <buffer> ]] :<c-u>call <SID>JumpMethod('}', 'W',  'v')<cr>
xnoremap <buffer> [] :<c-u>call <SID>JumpMethod('}', 'Wb', 'v')<cr>

onoremap <buffer> ][ :<c-u>call <SID>JumpMethod('{', 'W',  'o')<cr>
onoremap <buffer> [[ :<c-u>call <SID>JumpMethod('{', 'Wb', 'o')<cr>
onoremap <buffer> ]] :<c-u>call <SID>JumpMethod('}', 'W',  'o')<cr>
onoremap <buffer> [] :<c-u>call <SID>JumpMethod('}', 'Wb', 'o')<cr>

function! s:JumpMethod(char, flags, mode)
  let original_cursor = getpos('.')

  if a:mode == 'v'
    normal! gv
  elseif a:mode == 'o'
    normal! v
  endif

  while search(a:char, a:flags) > 0
    if a:char == '}'
      " jump to the opening one to analyze the definition
      normal! %
    endif

    let current_line = line('.')

    if getline(current_line) =~ '^\s*{'
      " it's alone on the line, check the above one
      let method_line = current_line - 1
    else
      let method_line = current_line
    endif

    let method_line_body = getline(method_line)

    if method_line_body =~ '\k\+\s*(.*)' && method_line_body !~ '\<\(for\|foreach\|if\|while\|switch\|using\|catch\|get\|set\)\>'
      " it's probably a function call

      if a:char == '}'
        " we need to go back to the closing bracket
        normal! %
      endif

      echo
      return
    else
      if a:char == '}'
        " we still need to go back to the closing bracket
        normal! %
      endif
    endif
  endwhile

  " if we're here, the search has failed, restore cursor position
  echo
  call setpos('.', original_cursor)
endfunction
" }}}

