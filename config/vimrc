" Wenzel's .vimrc

" Useful shortcuts:
" Ctrl-O/I: move forward/backwards through previously visited buffer positions

" use ]p/]P to paste while respecting the current indent level.
" gv re-selects a previous visual selection
" git log origin/master ^master --stat
" 
" <leader> s/f/F   -- EasyMotion 1 character searches
" <leader> j/k     -- EasyMotion row searches
" <leader> m       -- run make
" <leader> p/P     -- indented paste
" <leader> dw      -- remove trailing spaces
" <leader> dd      -- fix trailing ^M characters
" <leader> l       -- format Python/C++ code
" <leader> /       -- clear highlighted search results
" <leader><leader> -- comment/uncomment a code block

set nocompatible
"
" Plugins {{{

filetype off " Needed (this interferes with Vundle)

set rtp+=~/.vim/bundle/Vundle.vim/

call vundle#begin() " required

" Let Vundle manage Vundle (**)
Plugin 'gmarik/Vundle.vim'
" Assorted scripts, modified tomorrow night colorscheme (**)
Plugin 'wjakob/wjakob.vim'
" Airline status bar (**)
Plugin 'vim-airline/vim-airline'
Plugin 'vim-airline/vim-airline-themes'
" C++/Python autocompletion (**)
Plugin 'Valloric/YouCompleteMe'
" Git integration
Plugin 'tpope/vim-fugitive'
" Easily search for, substitute, and abbreviate multiple variants of a word
Plugin 'tpope/vim-abolish'
" GUI extension for the fugitive plugin
Plugin 'gregsexton/gitv'
" EasyMotion plugin
Plugin 'Lokaltog/vim-easymotion'
" Convenient recursive filename search
Plugin 'ctrlp.vim'
" Format Python files
Plugin 'tell-k/vim-autopep8'
" Ag searcher (*)
Plugin 'rking/ag.vim'
" Snippet manager (*)
" Plugin 'SirVer/ultisnips'
" Nice indentation marks (**)
Plugin 'Yggdroot/indentLine'
" Syntastic (**)
Plugin 'scrooloose/syntastic'
" Automatic generation of closing braces etc (**)
Plugin 'Raimondi/delimitMate'
" Easily comment / uncomment text (**)
Plugin 'scrooloose/nerdcommenter'
" Maximize a buffer and restore later on (C-W o)
Plugin 'regedarek/ZoomWin'
" Git gutter (**)
Plugin 'airblade/vim-gitgutter'
" Secure way of sourcing local vimrc files
Plugin 'MarcWeber/vim-addon-local-vimrc'
" Delete all but the current buffer (*)
Plugin 'vim-scripts/BufOnly.vim'
" Align tabular data (**)
Plugin 'godlygeek/tabular'
" Text object for Java/VIM/C functions
Plugin 'kana/vim-textobj-user'
Plugin 'kana/vim-textobj-function'
Plugin 'tikhomirov/vim-glsl'
" Hard mode :)
"Plugin 'takac/vim-hardtime'
" Support for directly opening file:linenumber -- causes issues
" Plugin 'bogado/file-line'

call vundle#end() " required

filetype plugin indent on

" }}}

" Core VIM settings {{{
set encoding=utf-8             " use UTF-8 (default latin1)
set autoread                   " auto-reload modified files (with no local changes)
set undolevels=65536           " lots of undo (default 1000)
set history=1024               " lots of history (default 20)
set mouse=a                    " enable mouse (set mouse= to disable mouse)
set hidden                     " allow un-saved buffers in background
set lazyredraw                 " no redraws in macros
set confirm                    " dialog when :q, :w, :x, :wq fails
set title                      " change terminal title
set nostartofline              " don't move cursor when switching buffers/files
set ttyfast                    " smoother changes
set backspace=2                " Backspace can move back beyond the start of the insertion
set backspace=indent,eol,start " Make backspace behave more like in other editors
set splitbelow                 " Open splits below (more natural), :sp makes a split
set splitright                 " Similar to the above (for vsplit)
let mapleader=","              " Map the leader key to comma
set nojoinspaces               " Don't insert two spaces after a period when joining lines

" Control what extra information is shown
set showmode                   " show which mode we are in
set showcmd                    " show state of keyboard input
set showmatch                  " show brace match
set matchtime=2                " when writing braces, only briefly flash the opening one (200ms)
set report=0                   " always report how many occurrences were changed by search/replace etc
set ruler                      " show position in bottom right
set winminheight=0             " allow to collapse down windows to their status line only

" Tabs, wrapping, folding, and indentation
set autoindent                 " automatic indentation
set copyindent                 " copy the previous indentation on autoindenting
set tabstop=4                  " Number of spaces that a <Tab> in the file counts for (default 8)
set shiftwidth=4               " Number of spaces to use for each step of (auto)indent.
set softtabstop=-1             " Disable softtabstop (reverts to shiftwidth)
set smarttab                   " insert tabs on the start of a line according to
                               " shiftwidth, not tabstop
set expandtab                  " Expand tabs to spaces
set textwidth=0                " no hard wrapping by default
set foldmethod=syntax          " fold using syntax by default
set foldminlines=4             " require a medium size to fold
set foldnestmax=3              " max 3 fold levels for syntax/indent folding

" Appearance
set number                     " enable line numbers
set scrolloff=3                " keep 3 lines below and above cursor
set linebreak                  " show wrap at word boundaries
set showbreak=\ ↪\             " prefix wrap with ↪

" Autocompletion
set wildmenu                   " completion with menu
set wildmode=full              " show list with navigation
set wildignore=*~,*.o,*.d,*.obj,*.class,*.pyc,*.bak,*.swp,.svn,.git,.hg,*.orig
set suffixes=~,.o,.d,.obj,.class,.pyc,.bak,.swp,.orig
set completeopt=menu,preview   " Completion with a menu

" Searching
set incsearch                  " incremental search
set hlsearch                   " enable search highlighting

" Store swapfiles in a central location
set backup
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set backupskip=/tmp/*,/private/tmp/*
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set writebackup

set spelllang=en
set spellfile=$HOME/Dropbox/spell-en.utf-8.add

" Window navigation {{{
" Move around using Alt + navigation keys
nnoremap <silent> <M-k> :wincmd k<CR>
nnoremap <silent> <M-j> :wincmd j<CR>
nnoremap <silent> <M-h> :wincmd h<CR>
nnoremap <silent> <M-l> :wincmd l<CR>
nnoremap <silent> <M-o> :ZoomWin<CR>

" As above (Mac keyboard)
nnoremap <silent> ˙ :wincmd h<CR>
nnoremap <silent> ∆ :wincmd j<CR>
nnoremap <silent> ˚ :wincmd k<CR>
nnoremap <silent> ¬ :wincmd l<CR>
nnoremap <silent> ø :ZoomWin<CR>

" Window resize / close commands
nnoremap <silent> <C-L> :vertical resize +5<cr>
nnoremap <silent> <C-H> :vertical resize -5<cr>
nnoremap <silent> <C-K> :resize -5<cr>
nnoremap <silent> <C-J> :resize +5<cr>
nnoremap <silent> <C-X> :wincmd c<CR>     " close
nnoremap <silent> <C-F> <C-W>_            " fullscreen

" Move to next / previous buffer
nnoremap <silent> < :bp<CR>
nnoremap <silent> > :bn<CR>

" ctrl+a : select all
nnoremap <C-A> 1GVG

" Replace colon and semicolon
nnoremap ; :
nnoremap : ;
vnoremap ; :
vnoremap : ;

" Use Q for formatting the current paragraph (or selection)
vnoremap Q gq
nnoremap Q gqap

" Map cn/cp to navigate through search results (formerly :cn/:cp)
nnoremap cn :cn<CR>zv
nnoremap cp :cp<CR>zv

" Allow 'gf' to jump to file:line links
nnoremap gf gF

" Bind F2 as a quick paste mode toggle key
set pastetoggle=<F2>

" Hide shown search results
nnoremap <silent> <leader>/ :nohlsearch<CR>

" Automaticall unfold when jumping to a line in a file
nnoremap <expr> G (v:count ? 'Gzv' : 'G')

" }}}

" Tell vim to remember certain things when we exit
"  '50  :  marks will be remembered for up to 50 previously edited files
"  "100 :  will save up to 100 lines for each register
"  :50  :  up to 20 lines of command-line history will be remembered
"  %    :  saves and restores the buffer list
"  n... :  where to save the viminfo files
set viminfo='50,\"100,:50,%

" }}}

" Global fixes {{{

" Be quiet
set noerrorbells visualbell t_vb=  " No bell
au GUIEnter * set visualbell t_vb= " No bell in GUI mode

" Faster timeouts
set timeout timeoutlen=1000 ttimeoutlen=100

" Use OS clipboard
if has('unix') && system("uname") == "Linux\n"
	set clipboard=unnamedplus  " Share X windows clipboard.
	if !has('gui_running')
		" Fix handling of Alt/Meta in Gnome Terminal
		let c='a'
		while c <= 'z'
		  exec "set <A-".c.">=\e".c
		  "exec "imap \e".c." <A-".c.">"
		  let c = nr2char(1+char2nr(c))
		endw
	endif
else
	set clipboard=unnamed      " Share system clipboard.
endif

" Re-adjust windows on window resize
au VimResized * wincmd =

" Insert mode -- don't create/close folds when typing
aug NoInsertFolding
	au!
	au InsertEnter * if !exists('w:last_fdm') | let w:last_fdm=&foldmethod | setlocal foldmethod=manual | endif
	au InsertLeave,WinLeave * if exists('w:last_fdm') | let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif
aug END

" Remove the toolbar if we're running under a GUI
if has("gui_running")
  set guioptions=-t
endif

if has('mac') && !has('nvim')
	fixdel
endif

" Jump to last known line when opening a file (change ' to ` to do column too)
au BufReadPost *
  \ if line("'\"") > 0 && line("'\"") <= line("$") |
  \   exe "normal g'\"" |
  \   if foldlevel('.') > 0 |
  \	 exe "normal zO" |
  \   endif |
  \ endif

" Delete trailing white space
fun! DeleteTrailingWS()
	let l:winview = winsaveview()
	%s/\s\+$//ge
	call winrestview(l:winview)
endfun

" }}}

" Color scheme {{{

set t_Co=256
set background=dark
syntax on
colorscheme tomorrow-night
hi Folded ctermfg=248 ctermbg=237 guibg=#3a3a3a guifg=#a8a8a8

hi SpellBad guibg=#FF0000

" }}}

" Plugin config {{{

" Syntastic
let g:syntastic_mode_map = { 'mode': 'passive',
    \ 'active_filetypes': ['python'],
    \ 'passive_filetypes': [] }
let g:syntastic_python_checkers = ['flake8']
let g:syntastic_python_flake8_args="--ignore=E126,E128,E221"

" Powerline -- fancy status line
"if !exists('g:airline_symbols')
	"let g:airline_symbols = {}
"endif
"let g:airline_left_sep = '⮀'
"let g:airline_left_alt_sep = '⮁'
"let g:airline_right_sep = '⮂'
"let g:airline_right_alt_sep = '⮃'
"let g:airline_symbols.branch = '⭠'
"let g:airline_symbols.readonly = '⭤'
"let g:airline_symbols.linenr = '⭡'
"let g:airline_powerline_fonts=1
"let g:airline#extensions#whitespace#enabled = 0
"let g:airline#extensions#tabline#enabled = 1
"let g:airline#extensions#tabline#left_sep = ' '
"let g:airline#extensions#tabline#left_alt_sep = '|'
"let g:airline_theme='base16'
let g:airline_powerline_fonts = 1
set laststatus=2  " 2 means always show status

" Nerd commenter
let g:NERDCreateDefaultMappings = 0
map <Leader><Leader> <Plug>NERDCommenterToggle

" YouCompleteMe settings
"let g:ycm_global_ycm_extra_conf = "~/.vim/.ycm_extra_conf.py"
let g:ycm_filetype_whitelist = {'cpp' : '', 'bib' : '', 'sh' : '', 'tex' : '', 'plaintex' : '', 'xml' : ''}
let g:ycm_key_list_previous_completion = ['<S-TAB>', '<Up>']
let g:ycm_key_list_select_completion = ['<TAB>', '<Down>']
let g:ycm_confirm_extra_conf = 0
let g:ycm_autoclose_preview_window_after_insertion = 1
let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_enable_diagnostic_signs = 0

" Disable automatic popups (too slow for C++ stuff)
let g:ycm_auto_trigger = 0

" CtrlP setting
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
"  ignore files
let g:ctrlp_custom_ignore = {
	\ 'dir':  '\.git$\|\.hg$\|\.svn\|\CMakeFiles$',
	\ 'file': '\.exe$\|\.so$\|\.dll$\|\.o$\|\.d$\|\.swp$\|\.orig$',
	\ }

" Search the whole repository (searches for .git/.hg/.svn..)
let g:ctrlp_working_path_mode = 'r'

" refresh file tree on write or focus change
augroup CtrlPExtension
  au!
  au FocusGained * ClearCtrlPCache
  au BufWritePost * ClearCtrlPCache
augroup END

" Bi-directional find motion
" Jump to anywhere you want with minimal keystrokes, with just one key binding.
" `s{char}{label}`
map <Leader> <Plug>(easymotion-prefix)
map s <Plug>(easymotion-s)

let g:autopep8_disable_show_diff = 1

" UltiSnips shortcuts
"let g:UltiSnipsExpandTrigger       = "<tab>"
"let g:UltiSnipsJumpForwardTrigger  = "<tab>"
"let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"

"function! g:UltiSnips_Complete()
	"call UltiSnips#ExpandSnippet()
	"if g:ulti_expand_res == 0
		"if pumvisible()
			"return "\<C-n>"
		"else
			"call UltiSnips#JumpForwards()
			"if g:ulti_jump_forwards_res == 0
			   "return "\<TAB>"
			"endif
		"endif
	"endif
	"return ""
"endfunction

"au InsertEnter * exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=g:UltiSnips_Complete()<cr><C-O>zv"

" Get rid of bad habits
let g:hardtime_default_on = 1
let g:hardtime_allow_different_key = 1
let g:hardtime_maxcount = 1
set mouse=
inoremap  <Up>     <NOP>
inoremap  <Down>   <NOP>
inoremap  <Left>   <NOP>
inoremap  <Right>  <NOP>
noremap   <Up>     <NOP>
noremap   <Down>   <NOP>
noremap   <Left>   <NOP>
noremap   <Right>  <NOP>

" Indentline
let g:indentLine_char = '¦'
let g:indentLine_color_term = 236
let g:indentLine_fileType = ['python']

" Convenient key binding for delimitMate
au FileType cpp inoremap <buffer> {<CR> {<CR>}<C-o>O

let g:indentLine_faster = 1

" Visualize TeX characters using the conceal feature
" " (accents, bold/italic, delimiters, greek, math symbols)
let g:tex_conceal="abgm"

set ambw="single"

" Folding for TeX files (disabled)
"let g:tex_fold_enabled = 1
" Don't spell-check comments
let g:tex_comment_nospell=1

let g:gitgutter_map_keys = 0
nmap [h <Plug>GitGutterPrevHunk
nmap ]h <Plug>GitGutterNextHunk
nmap <Leader>hs <Plug>GitGutterStageHunk
nmap <Leader>hr <Plug>GitGutterRevertHunk

" Set the right file type for Django when editing .html
au BufNewFile,BufRead *.html setlocal filetype=htmldjango

au BufNewFile,BufRead *.frag setlocal filetype=glsl
au BufNewFile,BufRead *.vert setlocal filetype=glsl
au BufNewFile,BufRead *.geo setlocal filetype=glsl

" }}}

" Filetype-specific settings {{{

" SCons* files are Python scripts
au BufRead,BufNewFile SCons* setlocal filetype=python

" Latex and Python: do not use tabs
au FileType cmake setlocal expandtab tabstop=2 shiftwidth=2
au FileType tex,plaintex setlocal expandtab | :call EnableConceal()
au FileType python setlocal expandtab | :call EnableConceal()

" Vimrc -- fold with markers
au FileType vim setlocal foldmethod=marker

" Mathematica binding files
au BufNewFile,BufRead *.tm setlocal filetype=cpp

" Spell-check text files
au FileType text,tex,plaintex,html,gitcommit setlocal spell

" Highlight repeated words
au FileType text,tex,plaintex,html syn match TmlDoubleWords /\c\<\(\S\+\)\_s\+\1\ze\_s/ containedin=ALL
au FileType text,tex,plaintex,html hi link TmlDoubleWords WarningMsg

" Autocompletion
au FileType python,cpp nnoremap <buffer> J :YcmCompleter GoTo<CR>zv

" }}}

" Mitsuba specific {{{

" Highlight trailing whitespace in the most annoying way possible.
fun! HighlightTrailingSpaces()
	hi ExtraWhitespace ctermbg=red guibg=red
	au ColorScheme * hi ExtraWhitespace ctermbg=red guibg=red
	match ExtraWhitespace /\s\+$/
	au BufWinEnter * match ExtraWhitespace /\s\+$/
	au InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
	au InsertLeave * match ExtraWhitespace /\s\+$/
endfun

let c_no_curly_error=1 " Be more lenient with C++11 syntax
au Syntax cpp syn keyword cType Float

au BufNewFile,BufRead *mitsuba* call HighlightTrailingSpaces()

" }}}

" PBRT editing environment {{{
python << EOF
def pbrt_search(search):
	import os, glob, vim
	search += ">="
	for name in list(glob.iglob('ch*.tex')) + list(glob.iglob('app*.tex')):
		with open(name, 'r') as f:
			lines = f.readlines()
			for row, text in enumerate(lines):
				col = text.find(search)
				if col != -1:
					vim.command("silent edit %s:%i:%i" % (name, row+1, col+1))
EOF

function! PBRTJump()
	let l:save_clipboard = &clipboard
	set clipboard= " Avoid clobbering the selection and clipboard registers.
	let l:save_reg = getreg('"')
	let l:save_regmode = getregtype('"')
	normal! ya<
	let l:text = @@
	call setreg('"', l:save_reg, l:save_regmode)
	let &clipboard = l:save_clipboard
	python pbrt_search(vim.eval('l:text'))
endfunction

function! PBRTTeXInit()
	if exists('b:current_syntax') && b:current_syntax == 'pbrt'
		return
	endif
	setlocal nocindent
	unlet! b:current_syntax
	syn include @CPP syntax/cpp.vim
	syn region cppSnip matchgroup=Snip start=/^@.*=$/ end=/^@\./ contains=@CPP
	syn region cppSnip matchgroup=Snip start=/^@.*=(.*)$/ end=/^@\./ contains=@CPP
	syn spell toplevel
	let b:current_syntax='pbrt'
	syn match phantomdfnCommand "\\phantomdfn{[^}]\{-}}"hs=s+12,he=e-1 containedin=texStatement contains=@NoSpell
	syn match useCommand "\\use{[^}]\{-}}"hs=s+5,he=e-1 containedin=texStatement contains=@NoSpell
	syn match monoCommand "\\mono{[^}]\{-}}"hs=s+6,he=e-1 containedin=texStatement contains=@NoSpell
	syn match refCommand "\\ref{[^}]\{-}}"hs=s+5,he=e-1 containedin=texStatement contains=@NoSpell
	syn match tagCommand "\\tag{[^}]\{-}}"hs=s+5,he=e-1 containedin=texStatement contains=@NoSpell
	syn match artCommand "\\art{[^}]\{-}}{[^}]\{-}}"hs=s+5,he=e-1 containedin=texStatement contains=@NoSpell

	hi phantomdfnCommand ctermfg=4
	hi useCommand ctermfg=4
	hi monoCommand ctermfg=4
	hi refCommand ctermfg=4
	hi tagCommand ctermfg=4
	nnoremap J :call PBRTJump()<CR>
	nnoremap <Leader>b :wa<CR>:silent! make! pdfbook \| :!open book.pdf<CR><CR>
endfunction

function! PBRTCPPInit()
	if exists('b:current_syntax') && b:current_syntax == 'pbrt'
		return
	endif
	let b:current_syntax='pbrt'
	call EnableConceal()
	syntax match PBRTRef /^\/\*\s\p*:\d*\s\*\/ / conceal
	"nnoremap <buffer>gf 3\|gF
	"nnoremap <buffer>i 3\|gFi
	"nnoremap <buffer>o 3\|gFo
	"nnoremap <buffer>I 3\|gFI
	"nnoremap <buffer>O 3\|gFO
	"nnoremap <buffer>d 3\|gFd
endfunction

au BufEnter,BufRead ~/projects/pbrt-3ed/book/*.tex call PBRTTeXInit()
au BufEnter,BufRead ~/projects/pbrt-3ed/src/*.h call PBRTCPPInit()
au BufEnter,BufRead ~/projects/pbrt-3ed/src/*.cpp call PBRTCPPInit()
au BufEnter,BufRead ~/nori2/* set et ts=4 sw=4

" }}}
"
" Other commands and abbreviations {{{

let &makeprg = 'ninja'

function! CommandCabbr(abbreviation, expansion)
  execute 'cabbr ' . a:abbreviation . ' <c-r>=getcmdpos() == 1 && getcmdtype() == ":" ? "' . a:expansion . '" : "' . a:abbreviation . '"<CR>'
endfunction

command! -nargs=+ CommandCabbr call CommandCabbr(<f-args>)

command! IPy execute 'IPython' | set foldmethod=marker | set foldmarker=#-,##

" Run make and don't prompt for ENTER
nnoremap <silent> <Leader>m :wa<CR>:silent! make! \| redraw! \| cw \| <CR><CR>zv
vnoremap <silent> <Leader>m :wa<CR>:silent! make! \| redraw! \| cw \| <CR><CR>zv
au BufEnter *.tex nnoremap <silent> <buffer> <Leader>m :wa<CR>:silent! make! \| redraw! \| <CR>
au BufEnter *.tex vnoremap <silent> <buffer> <Leader>m :wa<CR>:silent! make! \| redraw! \| <CR>

" w!! command which writes with root permissions
cmap w!! w !sudo tee % >/dev/null

"CommandCabbr build makec
CommandCabbr ag Ag
CommandCabbr bc Bclose
CommandCabbr git Git
CommandCabbr gitv Gitv

" Automatically insert C++ header gates for new h/hpp files
function! s:insert_gates()
  let gatename = '__' . substitute(toupper(expand("%:t")), "\\.", "_", "g")
  execute "normal! i#if !defined(" . gatename . ")\n#define " . gatename
  execute "normal! Go#endif /* " . gatename . " */"
  execute "normal! ggjo"
endfunction

au BufNewFile *.{h,hpp} call <SID>insert_gates()

function! ForwardSkipConceal(count)
	let cnt=a:count
	let mvcnt=0
	let c=col('.')
	let l=line('.')
	let lc=col('$')
	let line=getline('.')
	while cnt
		if c>=lc
			let mvcnt+=cnt
			break
		endif
		if stridx(&concealcursor, 'n')==-1
			let isconcealed=0
		else
			let [isconcealed, cchar, group]=synconcealed(l, c)
		endif
		if isconcealed
			let cnt-=strchars(cchar)
			let oldc=c
			let c+=1
			while c < lc
			  let [isconcealed2, cchar2, group2] = synconcealed(l, c)
			  if !isconcealed2 || cchar2!=cchar
				  break
			  endif
			  let c+= 1
			endwhile
			let mvcnt+=strchars(line[oldc-1:c-2])
		else
			let cnt-=1
			let mvcnt+=1
			let c+=len(matchstr(line[c-1:], '.'))
		endif
	endwhile
	return ":\<C-u>\e".mvcnt.'l'
endfunction

function! BackwardSkipConceal(count)
	let cnt=a:count
	let mvcnt=0
	let c=col('.')
	let l=line('.')
	let lc=0
	let line=getline('.')
	while cnt
		if c<=1
			let mvcnt+=cnt
			break
		endif
		if stridx(&concealcursor, 'n')==-1 || c == 0
			let isconcealed=0
		else
			let [isconcealed, cchar, group]=synconcealed(l, c-1)
		endif
		if isconcealed
			let cnt-=strchars(cchar)
			let oldc=c
			let c-=1
			while c>1
			  let [isconcealed2, cchar2, group2] = synconcealed(l, c-1)
			  if !isconcealed2 || cchar2!=cchar
					break
			  endif
			  let c-=1
			endwhile
			let c = max([c, 1])
			let mvcnt+=strchars(line[c-1:oldc-2])
		else
			let cnt-=1
			let mvcnt+=1
			let c-=len(matchstr(line[:c-2], '.$'))
		endif
	endwhile
	return ":\<C-u>\e".mvcnt.'h'
endfunction

function! EnableConceal()
	nnoremap <buffer> <expr> l ForwardSkipConceal(v:count1)
	nnoremap <buffer> <expr> h BackwardSkipConceal(v:count1)
	setlocal conceallevel=2 concealcursor=nc
endfunction
au BufEnter *.tex,*.py hi Conceal ctermfg=4 | set concealcursor=nc

" Move by displayed lines, not physical lines
nnoremap j gj
nnoremap k gk

" smart indent when entering insert mode with i on empty lines
function! IndentWithI()
	if len(getline('.')) == 0 && line('.') != line('$')
		return "\"_ddO"
	else
		return "i"
	endif
endfunction

nnoremap <expr> i IndentWithI()

" Execute a python script
au FileType python nnoremap <buffer> <leader>r <esc>:w !python3<cr>

" Paste into new line while respecting the current indent level
nmap <leader>P O<space><bs><esc>]pk"_dd
nmap <leader>p o<space><bs><esc>]pk"_dd

" <leader>l to format Python or C++ (visual and normal mode)
au FileType python nnoremap <buffer> <leader>l :call Autopep8()<cr><esc>:redraw!<CR>
au FileType python vnoremap <buffer> <leader>l :call Autopep8(printf(" --range %i %i", line("'<"), line("'>")))<cr><esc>:redraw!<CR>
au FileType cpp	nnoremap <silent> <buffer> <leader>l 1GVG:pyf $TERM_TOOLS/config/clang-format.py<cr>
au FileType cpp	vnoremap <silent> <buffer> <leader>l :pyf $TERM_TOOLS/config/clang-format.py<cr>

" remove trailing newlines
noremap <silent> <leader>dw <esc>:call DeleteTrailingWS()<cr>
" remove incorrect line endings from windows machines
noremap <leader>dd :%s/\r\n/\r/g<cr>

" Comments in cursive..
set t_ZH=[3m
set t_ZR=[23m
highlight Comment cterm=italic

nnoremap <buffer> ][ :<c-u>call <sid>jumpmethod('{', 'w',  'n')<cr>
nnoremap <buffer> [[ :<c-u>call <sid>jumpmethod('{', 'wb', 'n')<cr>
nnoremap <buffer> ]] :<c-u>call <sid>jumpmethod('}', 'w',  'n')<cr>
nnoremap <buffer> [] :<c-u>call <sid>jumpmethod('}', 'wb', 'n')<cr>

xnoremap <buffer> ][ :<c-u>call <sid>jumpmethod('{', 'w',  'v')<cr>
xnoremap <buffer> [[ :<c-u>call <sid>jumpmethod('{', 'wb', 'v')<cr>
xnoremap <buffer> ]] :<c-u>call <sid>jumpmethod('}', 'w',  'v')<cr>
xnoremap <buffer> [] :<c-u>call <sid>jumpmethod('}', 'wb', 'v')<cr>

onoremap <buffer> ][ :<c-u>call <sid>jumpmethod('{', 'w',  'o')<cr>
onoremap <buffer> [[ :<c-u>call <sid>jumpmethod('{', 'wb', 'o')<cr>
onoremap <buffer> ]] :<c-u>call <sid>jumpmethod('}', 'w',  'o')<cr>
onoremap <buffer> [] :<c-u>call <sid>jumpmethod('}', 'wb', 'o')<cr>

function! s:jumpmethod(char, flags, mode)
	let original_cursor = getpos('.')

	if a:mode == 'v'
		normal! gv
	elseif a:mode == 'o'
		normal! v
	endif

	while search(a:char, a:flags) > 0
		if a:char == '}'
			" jump to the opening one to analyze the definition
			normal! %
		endif

		let current_line = line('.')

		if getline(current_line) =~ '^\s*{'
			" it's alone on the line, check the above one
			let method_line = current_line - 1
		else
			let method_line = current_line
		endif

		let method_line_body = getline(method_line)

		if method_line_body =~ '\k\+\s*(.*)' && method_line_body !~ '\<\(for\|foreach\|if\|while\|switch\|using\|catch\|get\|set\)\>'
			" it's probably a function call

			if a:char == '}'
				" we need to go back to the closing bracket
				normal! %
			endif

			echo
			return
		else
			if a:char == '}'
				" we still need to go back to the closing bracket
				normal! %
			endif
		endif
	endwhile

	" if we're here, the search has failed, restore cursor position
	echo
	call setpos('.', original_cursor)
endfunction
" }}}
"
